# -*- coding: utf-8 -*-
# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

import gdb
from typing import Union, List, Dict
from crash.infra.lookup import SymbolCallback

EndIOSpecifier = Union[int, str, List[str], gdb.Value, gdb.Symbol, None]

class Decoder(object):
    """Decoder objects are used to unwind the storage stack

    They are relatively lightweight at runtime, meaning that the object
    is initialized but not decoded until it's needed.  The string will
    be formatted each time, but each Decoder's interpret() method will
    be called once.

    Attributes:
        interpreted (bool): Whether the contents of this Decoder have already
            been interpreted
    """
    __endio__: EndIOSpecifier = None

    def __init__(self):
        self.interpreted = False

    def interpret(self) -> None:
        """
        Interpret the Decoder object

        Rather than populate all the fields when they may not be used,
        we delay interpreting the object until the fields are needed.

        This method will examine the object passed to the derived class's
        constructor and produce the attributes required for each object.
        """
        pass

    def __getattr__(self, name):
        if self.interpreted:
            raise AttributeError(f"No such attribute `{name}'")

        self.interpret()
        self.interpreted = True
        return getattr(self, name)

    @classmethod
    def register(cls):
        """
        Registers a decoder with the storage decoder subsystem.

        Each Decoder contains the name of an endio routine.  When
        an object that needs decoding is encountered, the endio
        routine contained in the object is used to look up the decoder
        for that object.
        """
        register_decoder(cls.__endio__, cls)

    def __str__(self) -> str:
        """
        The printable description of this Decoder.  Typical Decoders
        include the address of the object, the block device it uses,
        and the location(s) affected by the object.
        """
        pass

    def __next__(self):
        """
        For stacked storage, the object may have been generated as part
        of an operation on another object.  e.g. a bio generated by
        buffer_head submission, a request generated by bio submission,
        a bio generated by another bio being cloned by device mapper, etc.

        In these scenarios, the __next__ method can be used to pass the
        next Decoder object in the chain.  It is not necessary to know
        the source of the object being decoded -- only its type is
        necessary.

        Typical uses will be 'return decode_bh(self.bh)' or
        'return decode_bio(self.next_bio)'

        If there are no objects beyond this one, it does not need to be
        overridden.
        """
        return None

class BadBHDecoder(Decoder):
    """
    Placeholder decoder for bad buffer_head pointers

    Rather than raise a NotAvailableError during decoding, we use a
    BadBHDecoder decoder to document where in the chain there was an
    invalid buffer_head.
    """
    description = "{:x} bh: invalid buffer_head"

    def __init__(self, bh):
        """
        Initialize a Decoder for `struct buffer_head' that describes
        a bad pointer

        Args:
            bh (gdb.Value<struct buffer_head>): The buffer_head to decode
        """
        super().__init__()
        self.bh = bh

    def __str__(self):
        return self.description.format(int(self.bh))

class GenericBHDecoder(Decoder):
    """
    Decodes a bio that references a struct buffer_head

    This method decodes a generic struct buffer_head, when no
    implementation-specific decoder is available

    Attributes:
        bh (gdb.Value<struct buffer_head>):
            The buffer head that was referenced from the bio
    """

    description = "{:x} buffer_head: for dev {}, block {}, size {} (undecoded)"

    def __init__(self, bh: gdb.Value):
        """
        Initalize a Decoder for `struct buffer_head' without any file
        system information associated with it

        Args:
            bio(gdb.Value<struct buffer_head>):
                The struct buffer_head to be decoded.
        """
        super().__init__()
        self.bh = bh

    def interpret(self):
        self.block_device = block_device_name(self.bh['b_bdev'])

    def __str__(self):
        return self.description.format(int(self.bh), self.block_device,
                                       self.bh['b_blocknr'], self.bh['b_size'])

_decoders: Dict[int, Decoder] = dict()

def register_decoder(endio: EndIOSpecifier, decoder: Decoder) -> None:
    """
    Registers a bio/buffer_head decoder with the storage subsystem.

    A decoder is a class that accepts a bio, buffer_head, or other object,
    potentially interprets the private members of the object, and
    returns a Decoder object that describes it.

    The only mandatory part of a Decoder is the __str__ method to
    print the description.

    If the bio is part of a stack, the __next__ method will contain
    the next Decoder object in the stack.  It does not necessarily need
    to be a bio.  The Decoder does not need to be registered unless it
    will be a top-level decoder.

    Other attributes can be added as-needed to allow informed callers
    to obtain direct information.

    Args:
        endio (str, list of str, gdb.Symbol, gdb.Value, or int): The function
            used as an endio callback.

            The str or list of str arguments are used to register a callback
            such that the Decoder is registered when the symbol is available.

            The gdb.Symbol, gdb.Value, and int versions are to be used
            once the symbol is available for resolution.

            If in doubt, use the names instead of the symbols objects.

        decoder (Decoder): The decoder class used to handle this object.

    """
    debug = False
    if isinstance(endio, str):
        if debug:
            print(f"Registering {endio} as callback")
        x = SymbolCallback(endio, lambda a: register_decoder(a, decoder))
        return
    elif isinstance(endio, list) and isinstance(endio[0], str):
        for sym in endio:
            if debug:
                print(f"Registering {sym} as callback")
            x = SymbolCallback(sym, lambda a: register_decoder(a, decoder))
        return

    if isinstance(endio, gdb.Symbol):
        endio = endio.value()

    if isinstance(endio, gdb.Value):
        endio = int(endio.address)

    if debug:
        print(f"Registering {endio:#x} for real")

    _decoders[endio] = decoder

class BadBioDecoder(Decoder):
    """
    Placeholder decoder for bad bio pointers

    Rather than raise a NotAvailableError during decoding, we use a
    BadBioDecoder decoder to document where in the chain there was an
    invalid bio.
    """
    description = "{:x} bio: invalid bio"

    def __init__(self, bio):
        """
        Initialize a Decoder for `struct bio' that describes a bad pointer

        Args:
            bio (gdb.Value<struct bio>): The bio to decode
        """
        super().__init__()
        self.bio = bio

    def __str__(self):
        return self.description.format(int(self.bio))

class GenericBioDecoder(Decoder):
    """
    Placeholder decoder for when we have a valid bio but nothing to decode it
    """
    description = "{:x} bio: undecoded bio on {} ({})"
    def __init__(self, bio):
        """
        Initialize a Decoder for `struct bio' for a bio with no other decoder

        Args:
            bio (gdb.Value<struct bio>): The bio to decode
        """
        super().__init__()
        self.bio = bio

    def __str__(self):
        return self.description.format(int(self.bio),
                                       block_device_name(self.bio['bi_bdev']),
                                       bio['bi_end_io'])

def decode_bio(bio: gdb.Value) -> Decoder:
    """
    Decodes a single bio, if possible

    This method will return a Decoder object describing a single bio
    after decoding it using a registered decoder, if available.

    If no decoder is registered, a generic description will be used.

    Args:
        bio (gdb.Value<struct bio>): The bio to decode

    Returns:
        BadBioDecoder: The bio was not valid
        GenericBioDecoder: The bio has no other decoder
        Decoder-derived object: The decoder appropriate for this bio type
    """

    try:
        return _decoders[int(bio['bi_end_io'])](bio)
    except KeyError:
        return GenericBioDecoder(bio)
    except gdb.NotAvailableError:
        return BadBioDecoder(bio)

def decode_bh(bh: gdb.Value) -> Decoder:
    """
    Decodes a single buffer_head, if possible

    This method will return a Decoder object describing a single buffer_head
    after decoding it using a registered decoder, if available.

    If no decoder is registered, a generic description will be used.

    Args:
        bh (gdb.Value<struct buffer_head>): The buffer_head to decode

    Returns:
        BadBHecoder: The bio was not valid
        GenericBHDecoder: The bio has no other decoder
        Decoder-derived object:
            The decoder appropriate for this buffer_head type
    """
    try:
        return _decoders[int(bh['b_end_io'])](bh)
    except KeyError:
        return GenericBHDecoder(bh)
    except gdb.NotAvailableError:
        return BadBHDecoder(bh)
